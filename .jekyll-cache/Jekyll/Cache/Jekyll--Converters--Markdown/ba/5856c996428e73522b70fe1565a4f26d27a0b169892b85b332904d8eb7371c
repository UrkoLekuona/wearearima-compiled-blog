I"ª<p>Los procesos batch han jugado un papel importante en las organizaciones desde hace mucho tiempo. Muchas tareas que no se pod√≠an asumir en aplicaciones online por ser muy pesadas, se pospon√≠an para se ejecutadas en horarios nocturnos por ejemplo.</p>

<p>Actualmente, los procesos batch siguen guardando ese protagonismo, incluso puede que est√© creciendo ya que tambi√©n se utilizan</p>

<p>Sin embargo, en procesos batch muy pesados o en volumenes de datos muy elevados, surge la duda si un proceso batch se va a ejecutar dentro de la ventana de tiempo establecida. Si el proceso batch supera los l√≠mites, tal vez se valoren otras soluciones basadas en arquitecturas distribu√≠das, tales como Map-Reduce o Spark.</p>

<h2 id="descripci√≥n-de-la-prueba">Descripci√≥n de la prueba</h2>

<p>Para quitarnos la duda de cuantos datos podemos procesar utilizando Spring Batch y cu√°nto tiempo tardar√≠amos hemos hecho unas pruebas de rendimiento utilizando un job muy sencillito que lee l√≠neas de texto de un fichero CSV y los almacena en dos tablas diferentes de una base de datos.</p>

<p><img src="/assets/images/2019-09-03-rendimiento-spring-batch/csv-to-tables.png" alt="csv-to-tables" /></p>

<p>Una de las tablas contiene 53 columnas con 3 √≠ndices configurados y la otra tiene 12 columnas con 3 √≠ndices tambi√©n.</p>

<p>Asimismo, las pruebas se han repetido con diferentes cantidades de datos para ver el impacto en el tiempo. Empezamos con 50.000 registros en el fichero CSV para ir subiendo de manera progresiva hasta un 1 mill√≥n de registros.</p>

<h2 id="tama√±o-de-chunk">Tama√±o de chunk</h2>

<p>Antes de presentar los resultados obtenidos en nuestras pruebas, vamos a explicar qu√© el par√°metro <code class="highlighter-rouge">tama√±o de chunk</code> y qu√© valor hemos aplicado.</p>

<p>Spring Batch va ejecutando el proceso batcn en grupos de registros y el tama√±o de chunk es el tama√±o de dicho grupo de registros. En nuestro ejemplo, si el tama√±o de chunk es de 10, se van leyendo registros del fichero csv de 10 en 10 para ir guard√°ndolos en base de datos.</p>

<p>En nuestra pruebas hemos probado diferentes tama√±os de chunk (100, 500 y 1000) y en este post s√≥lo vamos a recoger los resultados con el chunk de 500 ya que result√≥ ser la configuraci√≥n que mejor nos rindi√≥.</p>

<h2 id="resultados">Resultados</h2>

<h3 id="ejecuci√≥n-secuencial">Ejecuci√≥n secuencial</h3>

<p>En la primera prueba programamos el proceso batch para que fuera guardando los registros en base de datos de manera secuencial. M√°s adelante vamos a repetir la prueba empleando m√∫ltiples hilos para valorar cu√°nto mejoran los tiempo si ejecutamos el proceso en paralelo.</p>

<p>En este modo de ejecuci√≥n los resultados logrados fueron los siguientes:</p>

<table>
  <thead>
    <tr>
      <th>N¬∫ de registros</th>
      <th>50K</th>
      <th>100K</th>
      <th>250K</th>
      <th>500K</th>
      <th>1M</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Tiempo total (sg)</td>
      <td>17</td>
      <td>34</td>
      <td>87</td>
      <td>174</td>
      <td>337</td>
    </tr>
  </tbody>
</table>

<p>La primera conclusi√≥n que obtenemos es que el crecimiento en el tiempo es directamente proporcional a la cantidad de datos que vamos procesando. Por ejemplo, el tiempo para procesar un millon de registros es aproxim√°damente el diez veces el tiempo para procesar 100K de registros.</p>

<p>En la siguiente gr√°fica podemos ver la diferencia en los tiempos obtenidos en todos los casos:</p>

<p><img src="/assets/images/2019-09-03-rendimiento-spring-batch/rendimiento.png" alt="rendimiento-mysql" /></p>

<p>En base a estos datos, podemos estimar que en un hora podemos leer hasta 10 millones de registros desde un fichero CSV y almacenarlos en dos tablas de base de datos.</p>

<h3 id="ejecuci√≥n-en-paralelo-multithread">Ejecuci√≥n en paralelo (multithread)</h3>

<p>Si ejecutando el proceso batch de manera secuencial el rendimiento que logramos no es suficiente, podemos acelerar el proceso ejecut√°ndolo en paralelo mediante m√∫ltiples hilos.</p>

<p>Para valorar la mejora con el multithreading, hemos repetido la prueba configurando el job con un threadpool de 4 hilos (nuestra m√°quina s√≥lo tiene 2 cores y 4 threads).</p>

<table>
  <thead>
    <tr>
      <th>N¬∫ de registros</th>
      <th>50K</th>
      <th>100K</th>
      <th>250K</th>
      <th>500K</th>
      <th>1M</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Tiempo total (sg)</td>
      <td>10</td>
      <td>17</td>
      <td>44</td>
      <td>84</td>
      <td>178</td>
    </tr>
  </tbody>
</table>

<p>1 mill√≥n de registros le√≠dos del CSV y almacenados en dos tablas (2 millones de inserts) en 178 segundos, apenas 3 minutos. ¬°No est√° nada mal!</p>

<p>A continuaci√≥n actualizamos la gr√°fica para comparar los tiempos de ejecuci√≥n de ejecutar el job en un s√≥lo hilo vs 4 hilos:</p>

<p><img src="/assets/images/2019-09-03-rendimiento-spring-batch/rendimiento-multithread.png" alt="rendimiento-multithread" /></p>

<p>La mejora es muy significativa si podemos permitirnos la ejecuci√≥n de uno de los steps en paralelo utilizando m√°s hilos. Es importante ser consciente que la ejecuci√≥n en paralelo supone perder la caracter√≠stica de <a href="https://docs.spring.io/spring-batch/3.0.x/reference/html/configureJob.html#restartability">restartability de Spring Batch</a>. Esta funcionalidad consiste en que cuando falla la ejecuci√≥n del proceso batch, si reiniciamos el job Spring Batch iniciar√° el proceso desde el registro que se produjo el error. De lo contrario, si restartability est√° deshabilitado, el reiniciar el proceso Spring Batch comenzar√° desde el inicio.</p>

<h2 id="resumen">Resumen</h2>

<p>No est√° nada mal trat√°ndose de una m√°quina modesta y una instalaci√≥n de base de datos por defecto, sin ning√∫n tipo de optimizaci√≥n.</p>

<p>Un rendimiento m√°s que suficiente para la mayor√≠a de empresas que tengan que ejecutar tareas batch para procesar datos peri√≥dicamente y sin tener que montar un sistema basado en Hadoop, Spark o MapReduce.</p>

<p>Cuando se realizan pruebas de rendimiento, los datos pueden variar muchos por m√∫ltiple factores (versi√≥n de java, prestaciones de hw, etc). En nuestro caso las pruebas se han hecho sobre un MacBook Pro de principios de 2015, con un i7 de dos cores a 3,1GHz y 16 GB de RAM DDR3 a 1867 MHz, y se ha empleado la versi√≥n Java 8. Para poder contrastar los resultados obtenidos, hemos publicado el proyecto en <a href="#">este repositorio</a> de Github con todas las instrucciones necesarias.</p>
:ET